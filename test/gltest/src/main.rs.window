use glow::HasContext;
use glutin::event::{Event, WindowEvent};
use glutin::event_loop::{ControlFlow, EventLoop};
use glutin::window::WindowBuilder;
use glutin::ContextBuilder;

fn main() {
    // 创建事件循环
    let event_loop = EventLoop::new();

    // 创建窗口
    let window_builder = WindowBuilder::new().with_title("OpenGL with Glow");

    // 创建 OpenGL 上下文
    let windowed_context = ContextBuilder::new()
        .with_vsync(true)
        .build_windowed(window_builder, &event_loop)
        .unwrap();

    // 将上下文设为当前上下文
    let windowed_context = unsafe { windowed_context.make_current().unwrap() };

    // 初始化 glow 上下文
    let gl = unsafe {
        glow::Context::from_loader_function(|s| windowed_context.get_proc_address(s) as *const _)
    };

    // 开始渲染循环
    event_loop.run(move |event, _, control_flow| {
        *control_flow = ControlFlow::Wait;

        match event {
            Event::WindowEvent {
                event: WindowEvent::CloseRequested,
                ..
            } => {
                *control_flow = ControlFlow::Exit;
            }
            Event::MainEventsCleared => {
                // 渲染操作
                unsafe {
                    // 设置背景颜色并清屏
                    gl.clear_color(0.1, 0.2, 0.3, 1.0);
                    gl.clear(glow::COLOR_BUFFER_BIT);

                    // 创建一个简单的三角形着色器
                    let vertex_shader_source = r#"
                        #version 330
                        in vec2 a_position;
                        void main() {
                            gl_Position = vec4(a_position, 0.0, 1.0);
                        }
                    "#;
                    let fragment_shader_source = r#"
                        #version 330
                        out vec4 color;
                        void main() {
                            color = vec4(1.0, 0.0, 0.0, 1.0);  // 红色
                        }
                    "#;

                    // 编译顶点着色器
                    let vertex_shader = gl.create_shader(glow::VERTEX_SHADER).unwrap();
                    gl.shader_source(vertex_shader, vertex_shader_source);
                    gl.compile_shader(vertex_shader);
                    if !gl.get_shader_compile_status(vertex_shader) {
                        panic!("Vertex shader compilation failed: {}", gl.get_shader_info_log(vertex_shader));
                    }

                    // 编译片段着色器
                    let fragment_shader = gl.create_shader(glow::FRAGMENT_SHADER).unwrap();
                    gl.shader_source(fragment_shader, fragment_shader_source);
                    gl.compile_shader(fragment_shader);
                    if !gl.get_shader_compile_status(fragment_shader) {
                        panic!("Fragment shader compilation failed: {}", gl.get_shader_info_log(fragment_shader));
                    }

                    // 链接着色器程序
                    let program = gl.create_program().unwrap();
                    gl.attach_shader(program, vertex_shader);
                    gl.attach_shader(program, fragment_shader);
                    gl.link_program(program);
                    if !gl.get_program_link_status(program) {
                        panic!("Shader program linking failed: {}", gl.get_program_info_log(program));
                    }
                    gl.delete_shader(vertex_shader);
                    gl.delete_shader(fragment_shader);

                    // 创建顶点缓冲区
                    let vertices: [f32; 6] = [
                        -0.5, -0.5,  // 左下角
                         0.5, -0.5,  // 右下角
                         0.0,  0.5,  // 顶部
                    ];

                    let vertex_buffer = gl.create_buffer().unwrap();
                    gl.bind_buffer(glow::ARRAY_BUFFER, Some(vertex_buffer));
                    gl.buffer_data_u8_slice(glow::ARRAY_BUFFER, &vertices.align_to::<u8>().1, glow::STATIC_DRAW);

                    // 创建顶点数组对象
                    let vao = gl.create_vertex_array().unwrap();
                    gl.bind_vertex_array(Some(vao));

                    let pos_attrib = gl.get_attrib_location(program, "a_position").unwrap();
                    gl.enable_vertex_attrib_array(pos_attrib);
                    gl.vertex_attrib_pointer_f32(pos_attrib, 2, glow::FLOAT, false, 8, 0);

                    // 使用着色器程序
                    gl.use_program(Some(program));

                    // 绘制三角形
                    gl.draw_arrays(glow::TRIANGLES, 0, 3);

                    // 读取像素颜色
                    let (width, height) : (u32, u32)= windowed_context.window().inner_size().into();
                    let mut pixels = vec![0u8; (width as usize * height as usize * 4) as usize]; // 每个像素4字节（RGBA）
                    gl.read_pixels(
                        0,
                        0,
                        width as i32,
                        height as i32,
                        glow::RGBA,
                        glow::UNSIGNED_BYTE,
                        glow::PixelPackData::Slice(&mut pixels),
                    );

                    // 打印左下角像素颜色
                    println!("First pixel color: {:?}", &pixels[..4]);
                }

                // 交换缓冲区
                windowed_context.swap_buffers().unwrap();
            }
            _ => (),
        }
    });
}

